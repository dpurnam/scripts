# This script updates Cloudflare TLSA records by fetching DANE information directly from a Stalwart Mail Server Docker container.
# This script may be used to invoke via system cron every month

# Usage Instructions:
# Create a local bash script file Simply execute the command below or create a local bash script to do so
# curl -sL https://raw.githubusercontent.com/dpurnam/scripts/main/stalwart/cloudflare-tlsa-record-updater.sh | bash


# Important:
      # TLSA record must contain HOSTNAME of the Mail Server running Stalwart (in this ex. amdvps), regardless of number of email domains the mail server caters to.
      # If you've multiple Stalwart Mail servers, feel free to modify this script accordingly - changes would possibly include logic for additional variable HOSTNAME (for multiple hostnames) and appropriately updated DOMAIN_LIST
      # Stalwart Settings > Network > Host Name is configred as amdvps.domain1.tld
      # Dane best practice recommends usage of only '2 0 1' and '3 1 1' TLSA records. Lines 229 - 230 can be modified/expanded for additional TLSA records, if desired.
      # Hence the TLSA records on the Mail Server root domain (in our case domain1.tld) would be as below:
        # _25._tcp.amdvps  IN  TLSA  2 0 1 "<encrypted_cert_string>"
        # _25._tcp.amdvps  IN  TLSA  3 1 1 "<encrypted_cert_string>"
      # Stalwart is running as a docker container but in network_mode=host (as good as running a local binary but with a benefit of swift updates/rollbacks etc)
      # Stalwart API Key Permissions: 
          # Set to ON : View system settings, Refresh system settings, Retrieve specific domain information, Authenticate
          # Rest all permissions set to Default (Yet to test if rest all permissions can be set to Off). It's also possible to remove some of the above permissions - pending testing.
      # The script auto installs curl and jq packages on respective distro's
      # Change the STALWART_LOCAL_URL appropriately. In our case, we're using 'docker exec' to get DNS records generated by builtin ACME, hence the URL is "http://localhost:8080/api/dns/records/${domain_to_update}"

#!/bin/bash

# --- Configuration ---
# You must replace these with your actual API keys and container name.
STALWART_API_KEY="My_Stalwart_API_Key"
CLOUDFLARE_API_TOKEN="My_Cloudflare_API_Token"
STALWART_CONTAINER_NAME="stalwart" # <--- Set this to the actual name of your Stalwart Docker container

# --- Functions ---

# Function to install a package on Debian/Ubuntu systems
install_debian() {
    local package_name="$1"
    echo "Attempting to install ${package_name} using apt..."
    sudo apt update && sudo apt install -y "${package_name}"
    if [[ $? -ne 0 ]]; then
        echo "Error: Failed to install ${package_name} using apt. Please install it manually." >&2
        exit 1
    fi
}

# Function to install a package on RHEL/CentOS systems
install_rhel() {
    local package_name="$1"
    echo "Attempting to install ${package_name} using yum/dnf..."
    if command -v dnf &> /dev/null; then
        sudo dnf install -y "${package_name}"
    else
        sudo yum install -y "${package_name}"
    fi
    if [[ $? -ne 0 ]]; then
        echo "Error: Failed to install ${package_name} using yum/dnf. Please install it manually." >&2
        exit 1
    fi
}

# Function to install a package on Alpine Linux systems
install_alpine() {
    local package_name="$1"
    echo "Attempting to install ${package_name} using apk..."
    sudo apk add --no-cache "${package_name}"
    if [[ $? -ne 0 ]]; then
        echo "Error: Failed to install ${package_name} using apk. Please install it manually." >&2
        exit 1
    fi
}

# Function to check and install a binary on the host system
check_and_install_host_binary() {
    local binary_name="$1"
    local package_name="$2" # Package name might differ from binary name (e.g., 'jq' vs 'jq')

    if ! command -v "${binary_name}" &> /dev/null; then
        echo "${binary_name} is not installed. Attempting to install..."
        if [[ -f /etc/os-release ]]; then
            . /etc/os-release
            case "$ID" in
                debian|ubuntu)
                    install_debian "${package_name}"
                    ;;
                centos|rhel|fedora)
                    install_rhel "${package_name}"
                    ;;
                alpine)
                    install_alpine "${package_name}"
                    ;;
                *)
                    echo "Unsupported OS for automatic ${binary_name} installation. Please install ${binary_name} manually." >&2
                    exit 1
                    ;;
            esac
        else
            echo "Could not detect OS for automatic ${binary_name} installation. Please install ${binary_name} manually." >&2
            exit 1
        fi
    else
        echo "${binary_name} is already installed."
    fi
}

# Function to check and install curl inside the Docker container
check_and_install_container_curl() {
    local container_name="$1"

    # Define a simple command to check if curl exists in common paths
    # This will return 0 if curl is found, non-zero otherwise
    local check_cmd_in_container="test -f /usr/bin/curl || test -f /bin/curl"

    echo "Checking for 'curl' inside Docker container: ${container_name}..."

    # Execute the check command directly
    if docker exec "${container_name}" sh -c "${check_cmd_in_container}" &> /dev/null; then
        echo "'curl' is already installed inside ${container_name}."
        return 0 # Exit function successfully
    fi

    # If curl is not found by path, try to install it
    echo "'curl' not found in common paths inside ${container_name}. Attempting to install..."
    local install_cmd=""
    # Try common package managers inside the container
    if docker exec "${container_name}" sh -c "command -v apt-get &> /dev/null"; then
        install_cmd="apt-get update && apt-get install -y curl"
    elif docker exec "${container_name}" sh -c "command -v yum &> /dev/null"; then
        install_cmd="yum install -y curl"
    elif docker exec "${container_name}" sh -c "command -v dnf &> /dev/null"; then
        install_cmd="dnf install -y curl"
    elif docker exec "${container_name}" sh -c "command -v apk &> /dev/null"; then
        install_cmd="apk add --no-cache curl"
    fi

    if [[ -n "$install_cmd" ]]; then
        echo "Running install command inside container: docker exec ${container_name} sh -c \"${install_cmd}\""
        # Run the install command silently, but capture exit code
        docker exec "${container_name}" sh -c "${install_cmd}" &> /dev/null
        if [[ $? -ne 0 ]]; then
            echo "Warning: Package manager command for curl installation inside ${container_name} returned an error. This might be due to curl already being present or a real issue. Checking again if curl is now available." >&2
        fi
    else
        echo "Error: Could not determine package manager inside ${container_name} to install curl. Please install curl manually inside the container." >&2
        exit 1
    fi

    # Final verification: Check if curl is now callable (by common paths)
    if docker exec "${container_name}" sh -c "${check_cmd_in_container}" &> /dev/null; then
        echo "'curl' is now available inside ${container_name}."
    else
        echo "Error: 'curl' is still not found inside ${container_name} after attempted installation. Please install it manually." >&2
        exit 1
    fi
}

# Function to update TLSA records for a given domain
update_tlsa_records() {
    local domain_to_update="$1"
    local current_timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    local comment_text="Managed by TLSA-updater script on AMDVPS; Last sync: ${current_timestamp}"

    echo "--- Updating TLSA records for domain: $domain_to_update ---"

    # 1. Get the zone ID for the domain from Cloudflare
    ZONE_URL="https://api.cloudflare.com/client/v4/zones?name=${domain_to_update}"
    ZONE_RESPONSE=$(curl -s -H "Authorization: Bearer ${CLOUDFLARE_API_TOKEN}" -H "Content-Type: application/json" "${ZONE_URL}")

    ZONE_ID=$(echo "${ZONE_RESPONSE}" | jq -r '.result[0].id')

    if [[ -z "$ZONE_ID" || "$ZONE_ID" == "null" ]]; then
        echo "Error: Could not find Cloudflare Zone ID for domain: $domain_to_update. Response: $ZONE_RESPONSE"
        return 1
    fi
    echo "Cloudflare Zone ID for $domain_to_update: $ZONE_ID"

    # 2. Delete existing TLSA records (names of which contain 'amdvps') for this domain on Cloudflare
    echo "Fetching and deleting all existing TLSA records for ${domain_to_update} on Cloudflare..."
    DNS_RECORDS_URL="https://api.cloudflare.com/client/v4/zones/${ZONE_ID}/dns_records?type=TLSA"
    DNS_RECORDS_RESPONSE=$(curl -s -H "Authorization: Bearer ${CLOUDFLARE_API_TOKEN}" -H "Content-Type: application/json" "${DNS_RECORDS_URL}")

    if echo "${DNS_RECORDS_RESPONSE}" | jq -e '.result | type == "array"' > /dev/null; then
        echo "${DNS_RECORDS_RESPONSE}" | jq -c '.result[]' | while read -r existing_record; do
            RECORD_ID=$(echo "${existing_record}" | jq -r '.id')
            RECORD_NAME_EXISTING=$(echo "${existing_record}" | jq -r '.name') # Get existing record name for logging

            # Check if the existing record name contains '.amdvps.'
            if [[ "$RECORD_NAME_EXISTING" == *".amdvps."* ]]; then
                DELETE_URL="https://api.cloudflare.com/client/v4/zones/${ZONE_ID}/dns_records/${RECORD_ID}"
                DELETE_RESPONSE=$(curl -s -X DELETE -H "Authorization: Bearer ${CLOUDFLARE_API_TOKEN}" -H "Content-Type: application/json" "${DELETE_URL}")
                if echo "${DELETE_RESPONSE}" | jq -e '.success == true' > /dev/null; then
                    echo "Deleted TLSA record matching criteria: $RECORD_NAME_EXISTING (ID: $RECORD_ID)"
                else
                    echo "Failed to delete TLSA record: $RECORD_NAME_EXISTING (ID: $RECORD_ID). Response: $DELETE_RESPONSE"
                fi
            else
                echo "Skipping TLSA record deletion for: $RECORD_NAME_EXISTING (Does not end with '.amdvps')" # <--- Added log for skipped records
            fi
        done
        echo "Finished deleting existing TLSA records."
    else
        echo "No existing TLSA records found or Cloudflare API response for existing records was invalid for ${domain_to_update}. Proceeding to add new records."
    fi

    # 3. Get DNS entries for DANE from Stalwart
    local STALWART_LOCAL_URL="http://localhost:8080/api/dns/records/${domain_to_update}"
    echo "Fetching new TLSA records from Stalwart container: ${STALWART_CONTAINER_NAME} using URL: ${STALWART_LOCAL_URL}"

    STALWART_RESPONSE=$(docker exec "${STALWART_CONTAINER_NAME}" curl -s \
        -H "Authorization: Bearer ${STALWART_API_KEY}" \
        "${STALWART_LOCAL_URL}")

    # --- Debugging Stalwart Response ---
    echo "Raw Stalwart API Response (from Stalwart):"
    echo "${STALWART_RESPONSE}"
    echo "--- End Raw Stalwart API Response ---"

    if [[ -z "$STALWART_RESPONSE" ]]; then
        echo "Error: Stalwart API returned an empty response for $domain_to_update. No new TLSA records to add."
        return 1
    fi

    if ! echo "${STALWART_RESPONSE}" | jq -e '.data | type == "array"' > /dev/null; then
        echo "Error: Stalwart API response for $domain_to_update is not valid JSON or does not contain a 'data' array as expected. No new TLSA records to add."
        echo "Please check the structure of the Stalwart API response."
        return 1
    fi

    # 4. Add only '2 0 1' & '3 1 1' TLSA records from Stalwart to Cloudflare
    echo "Adding new TLSA records from Stalwart to Cloudflare..."
    echo "${STALWART_RESPONSE}" | jq -c '.data[] | select(.type == "TLSA")' | while read -r new_record; do
        RECORD_TYPE=$(echo "${new_record}" | jq -r '.type')
        local ORIGINAL_RECORD_NAME=$(echo "${new_record}" | jq -r '.name' | sed 's/\.$//') # Remove trailing dot
	local RECORD_NAME_FOR_MATCH="$ORIGINAL_RECORD_NAME"
	local FINAL_RECORD_NAME="${ORIGINAL_RECORD_NAME/.${domain_to_update}/.amdvps}"
        if [[ "$RECORD_NAME_FOR_MATCH" == *".$domain_to_update" || "$RECORD_NAME_FOR_MATCH" == "$domain_to_update" ]]; then
            CONTENT=$(echo "${new_record}" | jq -r '.content')
            IFS=' ' read -r USAGE SELECTOR MATCHING_TYPE CERTIFICATE <<< "$CONTENT"
            # --- NEW FILTERING LOGIC FOR DANE MODES ---
            if [[ ("$USAGE" == "2" && "$SELECTOR" == "0" && "$MATCHING_TYPE" == "1") || \
                  ("$USAGE" == "3" && "$SELECTOR" == "1" && "$MATCHING_TYPE" == "1") ]]; then
                # Construct DNS_DATA payload with the comment field
                DNS_DATA=$(jq -n \
                    --arg type "$RECORD_TYPE" \
                    --arg name "$FINAL_RECORD_NAME" \
                    --arg usage "$USAGE" \
                    --arg selector "$SELECTOR" \
                    --arg matching_type "$MATCHING_TYPE" \
                    --arg certificate "$CERTIFICATE" \
                    --arg comment "$comment_text" \
                    '{type: $type, name: $name, data: {usage: ($usage | tonumber), selector: ($selector | tonumber), matching_type: ($matching_type | tonumber), certificate: $certificate}, proxied: false, comment: $comment}')

                ADD_URL="https://api.cloudflare.com/client/v4/zones/${ZONE_ID}/dns_records"
                ADD_RESPONSE=$(curl -s -X POST -H "Authorization: Bearer ${CLOUDFLARE_API_TOKEN}" -H "Content-Type: application/json" -d "${DNS_DATA}" "${ADD_URL}")

                if echo "${ADD_RESPONSE}" | jq -e '.success == true' > /dev/null; then
                    echo "Added TLSA record: $FINAL_RECORD_NAME (Mode: $USAGE $SELECTOR $MATCHING_TYPE)"
                else
                    echo "Failed to add TLSA record: $FINAL_RECORD_NAME (Mode: $USAGE $SELECTOR $MATCHING_TYPE). Response: $ADD_RESPONSE"
                fi
            else
                echo "Skipping TLSA record '$ORIGINAL_RECORD_NAME' (Mode: $USAGE $SELECTOR $MATCHING_TYPE) as it does not match DANE best practices (2 0 1 or 3 1 1)."
            fi
	else
	    echo "Skipping TLSA record '$ORIGINAL_RECORD_NAME' from Stalwart as it does not belong to domain '$domain_to_update'."
	fi
    done

    echo "--- TLSA update for $domain_to_update complete. ---"
}


# --- Main Script Execution ---

echo "Starting TLSA record update process..."

# 1. Verify and install 'jq' on the host machine
check_and_install_host_binary "jq" "jq"

# 2. Verify and install 'curl' inside the Stalwart Docker container
check_and_install_container_curl "${STALWART_CONTAINER_NAME}"

# IMPORTANT: Replace with your actual domain names that need TLSA updates.
DOMAIN_LIST=("domain1.tld") # Adjust this list for all your email server host domains; since only amdvps.domain1.tld is the mail server, we don't need any other domains in this list

for domain in "${DOMAIN_LIST[@]}"; do
    update_tlsa_records "$domain"
done

echo "All TLSA record updates complete."

exit 0
